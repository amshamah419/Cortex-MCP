"""
Auto-generated MCP registries for unified tools (XSOAR and XSIAM).
Generated from OpenAPI specifications with whitelist filtering

DO NOT EDIT THIS FILE MANUALLY - generated by codegen/generator.py
"""

from __future__ import annotations

from typing import Any, Awaitable, Callable, Dict, List
import os
import json
import httpx
from mcp import types

TOOL_HANDLERS: Dict[str, Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]] = {}
TOOL_SCHEMAS: Dict[str, Dict[str, Any]] = {}
TOOL_DESCRIPTIONS: Dict[str, str] = {}

UNIFIED_INPUT_SCHEMA = {'type': 'object', 'properties': {'platform': {'type': 'string', 'enum': ['xsoar', 'xsiam'], 'description': 'Platform to use (xsoar or xsiam)'}, 'path': {'type': 'object', 'additionalProperties': True}, 'query': {'type': 'object', 'additionalProperties': True}, 'headers': {'type': 'object', 'additionalProperties': True}, 'body': {'oneOf': [{'type': 'object'}, {'type': 'array'}, {'type': 'string'}, {'type': 'number'}, {'type': 'boolean'}, {'type': 'null'}]}}, 'additionalProperties': False}

def _get_base_url(platform: str) -> str:
    if platform == "xsiam":
        return os.getenv("XSIAM_API_URL", "https://api-yourfqdn")
    else:
        return os.getenv("XSOAR_API_URL", "https://your-xsoar-instance.com")

def _get_http_client() -> httpx.AsyncClient:
    verify = os.getenv("VERIFY_SSL", "true").lower() == "true"
    timeout = float(os.getenv("API_TIMEOUT", "30"))
    return httpx.AsyncClient(timeout=timeout, verify=verify)

def _build_url(base_url: str, route: str, path_params: Dict[str, Any] | None) -> str:
    url = base_url + route
    if path_params:
        for k, v in path_params.items():
            url = url.replace("{" + k + "}", str(v))
    return url

def _sanitize_headers(headers: Dict[str, Any] | None, platform: str) -> Dict[str, str]:
    result: Dict[str, str] = {}
    if headers:
        for k, v in headers.items():
            if v is None:
                continue
            result[str(k)] = str(v)
    # Add XSIAM-specific auth headers if needed
    if platform == "xsiam":
        api_key = os.getenv("XSIAM_API_KEY")
        api_key_id = os.getenv("XSIAM_API_KEY_ID")
        if api_key and "Authorization" not in result:
            result["Authorization"] = api_key
        if api_key_id and "x-xdr-auth-id" not in result:
            result["x-xdr-auth-id"] = api_key_id
    elif platform == "xsoar":
        api_key = os.getenv("XSOAR_API_KEY")
        if api_key and "Authorization" not in result:
            result["Authorization"] = api_key
    return result

def _sanitize_query(query: Dict[str, Any] | None) -> Dict[str, Any]:
    return {} if query is None else dict(query)

def _make_unified_handler_get_incidents() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/incidents/get_incidents"
            method = "POST"
        else:
            route = "/incidents/search"
            method = "POST"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["get_incidents"] = _make_unified_handler_get_incidents()
TOOL_SCHEMAS["get_incidents"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["get_incidents"] = "Get a list of incidents filtered by various criteria"

def _make_unified_handler_update_incident() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/incidents/update_incident"
            method = "POST"
        else:
            route = "/incident"
            method = "PUT"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["update_incident"] = _make_unified_handler_update_incident()
TOOL_SCHEMAS["update_incident"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["update_incident"] = "Update an existing incident"

def _make_unified_handler_get_automation_scripts() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/scripts/get"
            method = "POST"
        else:
            route = "/automation/search"
            method = "POST"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["get_automation_scripts"] = _make_unified_handler_get_automation_scripts()
TOOL_SCHEMAS["get_automation_scripts"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["get_automation_scripts"] = "Get automation scripts"

def _make_unified_handler_save_or_update_script() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/scripts/insert"
            method = "POST"
        else:
            route = "/automation"
            method = "POST"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["save_or_update_script"] = _make_unified_handler_save_or_update_script()
TOOL_SCHEMAS["save_or_update_script"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["save_or_update_script"] = "Create or update an automation script"

def _make_unified_handler_import_script() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/scripts/insert"
            method = "POST"
        else:
            route = "/automation/import"
            method = "POST"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["import_script"] = _make_unified_handler_import_script()
TOOL_SCHEMAS["import_script"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["import_script"] = "Import an automation script"

def _make_unified_handler_delete_automation_script() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/scripts/delete"
            method = "POST"
        else:
            route = "/automation/delete"
            method = "POST"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["delete_automation_script"] = _make_unified_handler_delete_automation_script()
TOOL_SCHEMAS["delete_automation_script"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["delete_automation_script"] = "Delete an automation script"

def _make_unified_handler_get_audits() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:
    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:
        platform = arguments.get("platform", "xsoar")
        path = arguments.get("path")
        query = arguments.get("query")
        headers = arguments.get("headers")
        body = arguments.get("body")
        base_url = _get_base_url(platform)
        
        # Select route and method based on platform
        if platform == "xsiam":
            route = "/public_api/v1/audits/management_logs"
            method = "POST"
        else:
            route = "/settings/audits"
            method = "GET"
        
        url = _build_url(base_url, route, path)
        headers = _sanitize_headers(headers, platform)
        try:
            async with _get_http_client() as client:
                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)
                text = resp.text
                try:
                    data = resp.json()
                    text = json.dumps(data)
                except Exception:
                    pass
            return [types.TextContent(type='text', text=text)]
        except Exception as e:
            return [types.TextContent(type='text', text=f'ERROR: {e}')]
    return handler

TOOL_HANDLERS["get_audits"] = _make_unified_handler_get_audits()
TOOL_SCHEMAS["get_audits"] = UNIFIED_INPUT_SCHEMA
TOOL_DESCRIPTIONS["get_audits"] = "Get audit logs"


#!/usr/bin/env python3
"""
Simplified code generator: read OpenAPI specs and emit registry-based tools.
Each tool uses a uniform input schema: { path, query, headers, body }.
Supports whitelisting and unified tools that work across platforms.
"""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

COMMON_INPUT_SCHEMA = {
    "type": "object",
    "properties": {
        "path": {"type": "object", "additionalProperties": True},
        "query": {"type": "object", "additionalProperties": True},
        "headers": {"type": "object", "additionalProperties": True},
        "body": {
            "oneOf": [
                {"type": "object"},
                {"type": "array"},
                {"type": "string"},
                {"type": "number"},
                {"type": "boolean"},
                {"type": "null"},
            ]
        },
    },
    "additionalProperties": False,
}

UNIFIED_INPUT_SCHEMA = {
    "type": "object",
    "properties": {
        "platform": {
            "type": "string",
            "enum": ["xsoar", "xsiam"],
            "description": "Platform to use (xsoar or xsiam)"
        },
        "path": {"type": "object", "additionalProperties": True},
        "query": {"type": "object", "additionalProperties": True},
        "headers": {"type": "object", "additionalProperties": True},
        "body": {
            "oneOf": [
                {"type": "object"},
                {"type": "array"},
                {"type": "string"},
                {"type": "number"},
                {"type": "boolean"},
                {"type": "null"},
            ]
        },
    },
    "additionalProperties": False,
}


def to_snake_case(name: str) -> str:
    name = name.replace("-", "_").replace("/", "_")
    name = re.sub(r"[{}<>:]", "", name)
    s1 = re.sub("([^_])([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def clean_description(text: str | None) -> str:
    if not text:
        return ""
    text = text.replace("\r", " ").replace("\n", " ")
    text = re.sub(r"\s+", " ", text).strip()
    return text


def load_whitelist(whitelist_path: Path) -> Dict[str, Any]:
    """Load the whitelist configuration."""
    with open(whitelist_path, "r", encoding="utf-8") as f:
        return json.load(f)


def find_operation_in_spec(spec: Dict[str, Any], route: str, method: str, operation_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """Find an operation in the spec by route, method, and optionally operationId."""
    paths = spec.get("paths", {})
    if route not in paths:
        return None
    
    path_item = paths[route]
    method_lower = method.lower()
    if method_lower not in path_item:
        return None
    
    op = path_item[method_lower]
    if operation_id and op.get("operationId") != operation_id:
        return None
    
    return {
        "method": method.upper(),
        "route": route,
        "operationId": op.get("operationId"),
        "summary": op.get("summary", ""),
        "description": op.get("description", ""),
    }


def generate_unified_tools_file(whitelist: Dict[str, Any], xsiam_spec: Dict[str, Any], xsoar_spec: Dict[str, Any], output_dir: Path) -> None:
    """Generate unified tools that work across both platforms."""
    output_file = output_dir / "generated_unified_tools.py"
    
    lines: List[str] = []
    lines.append('"""')
    lines.append("Auto-generated MCP registries for unified tools (XSOAR and XSIAM).")
    lines.append("Generated from OpenAPI specifications with whitelist filtering")
    lines.append("")
    lines.append("DO NOT EDIT THIS FILE MANUALLY - generated by codegen/generator.py")
    lines.append('"""')
    lines.append("")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from typing import Any, Awaitable, Callable, Dict, List")
    lines.append("import os")
    lines.append("import json")
    lines.append("import httpx")
    lines.append("from mcp import types")
    lines.append("")
    lines.append("TOOL_HANDLERS: Dict[str, Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]] = {}")
    lines.append("TOOL_SCHEMAS: Dict[str, Dict[str, Any]] = {}")
    lines.append("TOOL_DESCRIPTIONS: Dict[str, str] = {}")
    lines.append("")
    lines.append("UNIFIED_INPUT_SCHEMA = " + repr(UNIFIED_INPUT_SCHEMA))
    lines.append("")
    lines.append("def _get_base_url(platform: str) -> str:")
    lines.append('    if platform == "xsiam":')
    lines.append('        return os.getenv("XSIAM_API_URL", "https://api-yourfqdn")')
    lines.append('    else:')
    lines.append('        return os.getenv("XSOAR_API_URL", "https://your-xsoar-instance.com")')
    lines.append("")
    lines.append("def _get_http_client() -> httpx.AsyncClient:")
    lines.append('    verify = os.getenv("VERIFY_SSL", "true").lower() == "true"')
    lines.append('    timeout = float(os.getenv("API_TIMEOUT", "30"))')
    lines.append("    return httpx.AsyncClient(timeout=timeout, verify=verify)")
    lines.append("")
    lines.append("def _build_url(base_url: str, route: str, path_params: Dict[str, Any] | None) -> str:")
    lines.append("    url = base_url + route")
    lines.append("    if path_params:")
    lines.append('        for k, v in path_params.items():')
    lines.append('            url = url.replace("{" + k + "}", str(v))')
    lines.append("    return url")
    lines.append("")
    lines.append("def _sanitize_headers(headers: Dict[str, Any] | None, platform: str) -> Dict[str, str]:")
    lines.append("    result: Dict[str, str] = {}")
    lines.append("    if headers:")
    lines.append("        for k, v in headers.items():")
    lines.append("            if v is None:")
    lines.append("                continue")
    lines.append("            result[str(k)] = str(v)")
    lines.append("    # Add XSIAM-specific auth headers if needed")
    lines.append('    if platform == "xsiam":')
    lines.append('        api_key = os.getenv("XSIAM_API_KEY")')
    lines.append('        api_key_id = os.getenv("XSIAM_API_KEY_ID")')
    lines.append('        if api_key and "Authorization" not in result:')
    lines.append('            result["Authorization"] = api_key')
    lines.append('        if api_key_id and "x-xdr-auth-id" not in result:')
    lines.append('            result["x-xdr-auth-id"] = api_key_id')
    lines.append('    elif platform == "xsoar":')
    lines.append('        api_key = os.getenv("XSOAR_API_KEY")')
    lines.append('        if api_key and "Authorization" not in result:')
    lines.append('            result["Authorization"] = api_key')
    lines.append("    return result")
    lines.append("")
    lines.append("def _sanitize_query(query: Dict[str, Any] | None) -> Dict[str, Any]:")
    lines.append("    return {} if query is None else dict(query)")
    lines.append("")
    
    unified_tools = whitelist.get("unified", {})
    
    for tool_name, tool_config in unified_tools.items():
        xsoar_config = tool_config.get("xsoar", {})
        xsiam_config = tool_config.get("xsiam", {})
        description = tool_config.get("description", "")
        
        xsoar_route = xsoar_config.get("route")
        xsoar_method = xsoar_config.get("method", "POST")
        xsiam_route = xsiam_config.get("route")
        xsiam_method = xsiam_config.get("method", "POST")
        
        # Generate unified handler
        handler_name = f"_make_unified_handler_{tool_name}"
        lines.append(f"def {handler_name}() -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:")
        lines.append("    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:")
        lines.append('        platform = arguments.get("platform", "xsoar")')
        lines.append('        path = arguments.get("path")')
        lines.append('        query = arguments.get("query")')
        lines.append('        headers = arguments.get("headers")')
        lines.append('        body = arguments.get("body")')
        lines.append("        base_url = _get_base_url(platform)")
        lines.append("        ")
        lines.append("        # Select route and method based on platform")
        lines.append(f'        if platform == "xsiam":')
        lines.append(f'            route = {json.dumps(xsiam_route)}')
        lines.append(f'            method = {json.dumps(xsiam_method)}')
        lines.append(f'        else:')
        lines.append(f'            route = {json.dumps(xsoar_route)}')
        lines.append(f'            method = {json.dumps(xsoar_method)}')
        lines.append("        ")
        lines.append("        url = _build_url(base_url, route, path)")
        lines.append("        headers = _sanitize_headers(headers, platform)")
        lines.append("        try:")
        lines.append("            async with _get_http_client() as client:")
        lines.append("                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=headers, json=body)")
        lines.append("                text = resp.text")
        lines.append("                try:")
        lines.append("                    data = resp.json()")
        lines.append("                    text = json.dumps(data)")
        lines.append("                except Exception:")
        lines.append("                    pass")
        lines.append("            return [types.TextContent(type='text', text=text)]")
        lines.append("        except Exception as e:")
        lines.append("            return [types.TextContent(type='text', text=f'ERROR: {e}')]")
        lines.append("    return handler")
        lines.append("")
        
        # Register the tool
        tool_display_name = tool_name
        lines.append(f"TOOL_HANDLERS[{json.dumps(tool_display_name)}] = {handler_name}()")
        lines.append(f"TOOL_SCHEMAS[{json.dumps(tool_display_name)}] = UNIFIED_INPUT_SCHEMA")
        lines.append(f"TOOL_DESCRIPTIONS[{json.dumps(tool_display_name)}] = {json.dumps(description)}")
        lines.append("")
    
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")
    
    print(f"Generated {output_file} with {len(unified_tools)} unified tools")


def generate_platform_tools_file(spec_path: Path, output_dir: Path, whitelist: Dict[str, Any], platform: str) -> None:
    """Generate platform-specific tools filtered by whitelist."""
    # Load the spec
    with open(spec_path, "r", encoding="utf-8") as f:
        spec = json.load(f)
    
    output_file = output_dir / f"generated_{platform}_tools.py"
    
    # Get whitelisted operations for this platform
    platform_whitelist = whitelist.get(platform, {})
    
    # Prepare operations from whitelist
    operations: List[Dict[str, Any]] = []
    for tool_name, tool_config in platform_whitelist.items():
        route = tool_config.get("route")
        method = tool_config.get("method", "POST")
        operation_id = tool_config.get("operationId")
        
        op = find_operation_in_spec(spec, route, method, operation_id)
        if op:
            op["tool_name"] = tool_name
            op["description"] = tool_config.get("description", "")
            operations.append(op)
        else:
            print(f"Warning: Operation not found in spec: {route} {method} ({operation_id})")
    
    # Build Python file
    lines: List[str] = []
    lines.append('"""')
    lines.append(f"Auto-generated MCP registries for {platform.upper()}.")
    lines.append(f"Generated from OpenAPI specification: {spec_path.name}")
    lines.append("Filtered by whitelist configuration")
    lines.append("")
    lines.append("DO NOT EDIT THIS FILE MANUALLY - generated by codegen/generator.py")
    lines.append('"""')
    lines.append("")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from typing import Any, Awaitable, Callable, Dict, List")
    lines.append("import os")
    lines.append("import json")
    lines.append("import httpx")
    lines.append("from mcp import types")
    lines.append("")
    lines.append("TOOL_HANDLERS: Dict[str, Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]] = {}")
    lines.append("TOOL_SCHEMAS: Dict[str, Dict[str, Any]] = {}")
    lines.append("TOOL_DESCRIPTIONS: Dict[str, str] = {}")
    lines.append("")
    lines.append("COMMON_INPUT_SCHEMA = " + repr(COMMON_INPUT_SCHEMA))
    lines.append("")
    lines.append("def _get_base_url() -> str:")
    if platform == "xsiam":
        lines.append('    return os.getenv("XSIAM_API_URL", "https://api-yourfqdn")')
    else:
        lines.append('    return os.getenv("XSOAR_API_URL", "https://your-xsoar-instance.com")')
    lines.append("")
    lines.append("def _get_http_client() -> httpx.AsyncClient:")
    lines.append('    verify = os.getenv("VERIFY_SSL", "true").lower() == "true"')
    lines.append('    timeout = float(os.getenv("API_TIMEOUT", "30"))')
    lines.append("    return httpx.AsyncClient(timeout=timeout, verify=verify)")
    lines.append("")
    lines.append("def _build_url(base_url: str, route: str, path_params: Dict[str, Any] | None) -> str:")
    lines.append("    url = base_url + route")
    lines.append("    if path_params:")
    lines.append('        for k, v in path_params.items():')
    lines.append('            url = url.replace("{" + k + "}", str(v))')
    lines.append("    return url")
    lines.append("")
    lines.append("def _sanitize_headers(headers: Dict[str, Any] | None) -> Dict[str, str]:")
    lines.append("    result: Dict[str, str] = {}")
    lines.append("    if headers:")
    lines.append("        for k, v in headers.items():")
    lines.append("            if v is None:")
    lines.append("                continue")
    lines.append("            result[str(k)] = str(v)")
    if platform == "xsiam":
        lines.append("    # Add XSIAM auth headers if not provided")
        lines.append('    api_key = os.getenv("XSIAM_API_KEY")')
        lines.append('    api_key_id = os.getenv("XSIAM_API_KEY_ID")')
        lines.append('    if api_key and "Authorization" not in result:')
        lines.append('        result["Authorization"] = api_key')
        lines.append('    if api_key_id and "x-xdr-auth-id" not in result:')
        lines.append('        result["x-xdr-auth-id"] = api_key_id')
    else:
        lines.append("    # Add XSOAR auth header if not provided")
        lines.append('    api_key = os.getenv("XSOAR_API_KEY")')
        lines.append('    if api_key and "Authorization" not in result:')
        lines.append('        result["Authorization"] = api_key')
    lines.append("    return result")
    lines.append("")
    lines.append("def _sanitize_query(query: Dict[str, Any] | None) -> Dict[str, Any]:")
    lines.append("    return {} if query is None else dict(query)")
    lines.append("")
    lines.append("def _make_handler(method: str, route: str) -> Callable[[Dict[str, Any]], Awaitable[List[types.TextContent]]]:")
    lines.append("    async def handler(arguments: Dict[str, Any]) -> List[types.TextContent]:")
    lines.append('        path = arguments.get("path")')
    lines.append('        query = arguments.get("query")')
    lines.append('        headers = arguments.get("headers")')
    lines.append('        body = arguments.get("body")')
    lines.append("        base_url = _get_base_url()")
    lines.append("        url = _build_url(base_url, route, path)")
    lines.append("        try:")
    lines.append("            async with _get_http_client() as client:")
    lines.append("                resp = await client.request(method=method, url=url, params=_sanitize_query(query), headers=_sanitize_headers(headers), json=body)")
    lines.append("                text = resp.text")
    lines.append("                try:")
    lines.append("                    data = resp.json()")
    lines.append("                    text = json.dumps(data)")
    lines.append("                except Exception:")
    lines.append("                    pass")
    lines.append("            return [types.TextContent(type='text', text=text)]")
    lines.append("        except Exception as e:")
    lines.append("            return [types.TextContent(type='text', text=f'ERROR: {e}')]")
    lines.append("    return handler")
    lines.append("")
    
    used_names: set[str] = set()
    for op in operations:
        method = op["method"]
        route = op["route"]
        tool_name = op.get("tool_name", to_snake_case(op.get("operationId", "")))
        desc = op.get("description") or clean_description(op.get("description") or op.get("summary"))
        
        # Use platform prefix
        tool_display_name = f"{platform}_{tool_name}"
        
        # Ensure uniqueness
        idx = 2
        unique_name = tool_display_name
        while unique_name in used_names:
            unique_name = f"{tool_display_name}_{idx}"
            idx += 1
        used_names.add(unique_name)
        
        lines.append(f"TOOL_HANDLERS[{json.dumps(unique_name)}] = _make_handler({json.dumps(method)}, {json.dumps(route)})")
        lines.append(f"TOOL_SCHEMAS[{json.dumps(unique_name)}] = COMMON_INPUT_SCHEMA")
        lines.append(f"TOOL_DESCRIPTIONS[{json.dumps(unique_name)}] = {json.dumps(desc)}")
        lines.append("")
    
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")
    
    print(f"Generated {output_file} with {len(operations)} tools")


def main() -> None:
    project_root = Path(__file__).parent.parent
    specs_dir = project_root / "specs"
    output_dir = project_root / "server"
    whitelist_path = project_root / "codegen" / "whitelist.json"
    output_dir.mkdir(exist_ok=True)
    
    # Load whitelist
    if not whitelist_path.exists():
        print(f"Error: Whitelist file not found: {whitelist_path}")
        return
    
    whitelist = load_whitelist(whitelist_path)
    
    # Load both specs for unified tools
    xsiam_spec_path = specs_dir / "xsiam.json"
    xsoar_spec_path = specs_dir / "xsoar.json"
    
    if not xsiam_spec_path.exists() or not xsoar_spec_path.exists():
        print("Error: Spec files not found")
        return
    
    with open(xsiam_spec_path, "r", encoding="utf-8") as f:
        xsiam_spec = json.load(f)
    
    with open(xsoar_spec_path, "r", encoding="utf-8") as f:
        xsoar_spec = json.load(f)
    
    # Generate unified tools
    print("Generating unified tools...")
    generate_unified_tools_file(whitelist, xsiam_spec, xsoar_spec, output_dir)
    
    # Generate platform-specific tools
    print("\nGenerating platform-specific tools...")
    generate_platform_tools_file(xsiam_spec_path, output_dir, whitelist, "xsiam")
    generate_platform_tools_file(xsoar_spec_path, output_dir, whitelist, "xsoar")
    
    # Count total tools
    unified_count = len(whitelist.get("unified", {}))
    xsiam_count = len(whitelist.get("xsiam", {}))
    xsoar_count = len(whitelist.get("xsoar", {}))
    total = unified_count + xsiam_count + xsoar_count
    
    print(f"\nGenerated tool files:")
    print(f"  - Unified tools: {unified_count}")
    print(f"  - XSIAM tools: {xsiam_count}")
    print(f"  - XSOAR tools: {xsoar_count}")
    print(f"  - Total: {total} tools")


if __name__ == "__main__":
    main()
